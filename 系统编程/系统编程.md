# 系统编程
## 多进程多线程编程
* 应用场景
    * 打开ps、3DMAX这要的大型软件时需要加载很多模块和动态连接库，软件启动时间会比较长，可以使用一个线程来显示一个小动画来表示当前软件正在启动，当后台线程加载完所有的模块和库之后，结束该动画的播放并打开软件主界面；
    * 字处理软件可以使用一个优先级高的线程来接收用户键盘输入，而使用一些优先级线程来进行拼写检查、语法检查、分页以及字数统计之类的功能并将结果显示在状态栏上，对于提高用户体验有重要帮助。
* 功能作用  
1、在单处理器、单核平台上，多个线程轮流进入CPU执行特定任务  
2、在多核、多处理器平台上，在任意时刻每个核可以运行一个线程，多个线程同时运行并相互协作，从而达到告诉处理任务的目的。  
3、即使是高端服务器或工作站甚至集群系统，处理器和核的数量总是有限的，如果线程的数量多于核的数量，就必然要进行调度。  
4，在调度时，处理器为每个线程分配一个很短的时间片，所有线程根据具体的调度算法轮流获得该时间片。当时间片用完后，即使该线程还没有执行完也要退出处理器并等待下次调度，同时由操作系统按照优先级再选择一个线程进入CPU运行。  
5、对于单核单CPU而言，使用多线程并不能提高任务处理速度，但有些场合必须使用多线程技术，例如gui界面的用户体验。  
6、并不是使用的线程数量越多越好，如果线程太多的话，线程调度带来的开销可能会比线程实际执行的开销还大，这样使用多线程就失去本来的意义了。
## 线程
* 常用函数
    * active_count()		返回当前处于alive状态的Thread
    * current_thread()	返回当前的Thread对象
    * threading.get_ident()	返回当前线程的标识符
    * enumerate（）	返回当前处于alive状态的所有
   *  main_thread()		返回主线程对象
   *  get_ident() 获取线程标识符
   *  main_thread()  主线程
   *  stack_size([size])  当前线程使用栈的大小，size 32k以上  32*1024  byte
* 线程方法：
   *  daemon	是否为守护线程 False	daemon=False
   *  setdaemon（False） 	默认为False，即不是守护线程
  *   getName	获取线程名字
   *  isAlive / is_alive	是否为活动进程
   *  isDaemon	是否为守护线程
   *  join（[timeout]）		阻塞主线程,timeout为最长等待时间
* 线程属性
    * name	线程名字
    * start		线程运行
    * ident	线程的标识符
## 锁
* Lock  锁
	* acquire 上锁，获取锁
	* release 解锁，释放锁
* Rlock  复用锁，递归锁，可以锁很多次，但是解锁要一一对应
* Semaphore  信号锁
* Condition  条件锁
	* 生产者消费者模式
	* 使用Condition对象可以在某些事件出发后才处理数据或执行特定的代码
* Event  事件锁
### 意义
在python中没存在了GIL，也就是全局解释器锁，从而在每次进行获得CPU的时候，同时只有一个线程获得了cpu的运行，在这方面可以认为是线程安全的，但是在线程运行的时候，是共享内存的，共享相同的数据信息，从而这个时候python的线程就不那么安全了。在python中，要保证数据的正确性，冰球自己对数据进行控制，对数据进行加锁并且自己释放锁。
### 概述
将任务拆分成互相写作的的多个线程同时运行，那么属于同一个任务的多个线程之间必然会有交互和同步以便互相协作的完成任务  
多线程同步时如果需要获得多个锁才能进入临界区的话，可能会发生死锁，在多线程编程时一定要注意并认真检查和避免这种情况
### 定义
Lock是比较低级的同步原语，当被锁定之后不属于特定的线程。  
一个锁有两种状态：locked和unlocked。如果锁处于unclocked状态，acquire（）方法将棋修改为locked并立即返回；如果锁已处于locked状态，则阻塞当前线程并等待其他线程释放锁然后将其修改为locked并立即返回，或等待一定时间后返回但不修改锁的状态  
release（）方法将锁状态由locked修改为unlocked并立即返回，如果锁状态本来已经是unlocked，调用该方法将会抛出异常